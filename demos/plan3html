
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Three.js Geometry Browser</title>
		<style>
			html,body{width:100%; height:100%;}
			body {
				margin:0;
				font-family: '微软雅黑';
				font-size: 15px;
				line-height: 18px;
				overflow: hidden;
				background:url(../imgs/home_bg.jpg) no-repeat center center;
				background-size:cover;
			}

			canvas { width: 100%; height: 100% }

		</style>
	</head>
	<body>
		<script src="http://techbrood.com/threejs/build/three.min.js"></script>
    	<script src="https://jasonchen1982.github.io/three.interaction.js/build/three.interaction.js"></script>
		<script src="http://techbrood.com/threejs/examples/js/controls/OrbitControls.js"></script>
		<script>

			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
			camera.position.z = 30;

			// var cameraHelper = new THREE.CameraHelper( camera );
			// scene.add( cameraHelper );

            var renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true
            });
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

			var orbit = new THREE.OrbitControls( camera, renderer.domElement );
			// orbit.enabled = false;
			// orbit.enableZoom = false;
			// orbit.enableRotate = false;
			// orbit.autoRotate = true; //自动旋转
			// orbit.autoRotateSpeed = 4; //旋转速度


			var ambientLight = new THREE.AmbientLight(0xffffff);
			scene.add(ambientLight);

			var interaction = new THREE.Interaction(renderer, scene, camera);

// 坐标线
// var axesHelper = new THREE.AxesHelper( 100 );
// scene.add( axesHelper );

//立方体
var cubeGeometry = new THREE.Geometry();

//创建立方体的顶点
var r = 8;
var vertices = [
	new THREE.Vector3(r, r, r), //v0
	new THREE.Vector3(-r, -r, r), //v1
    new THREE.Vector3(-r, r, -r), //v2
    new THREE.Vector3(r, -r, -r), //v3
    
];
cubeGeometry.vertices = vertices;  //设置立方体的各个坐标点
//创建立方的面，各个面的排列顺序
var faces=[
	new THREE.Face3(0,1,2),
    new THREE.Face3(1,3,2),
    new THREE.Face3(2,3,0),
    new THREE.Face3(3,1,0),
];
cubeGeometry.faces = faces;

console.log('cubeGeometry',cubeGeometry.faces);

//给立方体设置贴图
var materials = [];  //创建一个贴图数组
//设置贴图数组
for(var i = 0;i < cubeGeometry.faces.length;i++){
	materials[i] = new THREE.MeshBasicMaterial({
        // map: new THREE.TextureLoader().load('../imgs/texture' + (i+1) + '.jpg?'+new Date().getTime()),
        map: new THREE.TextureLoader().load('../imgs/texture_new-0' + (i+1) + '.jpg?'+new Date().getTime()),
        side: THREE.DoubleSide,
	})
}
console.log('materials',materials);

//记录每个面的id，将纹理坐标和faceid间接关联，否则纹理图片始终都是第一张的图片
var faceId = 0;
var uv = [
    new THREE.Vector2(0,0), //图片左下角
    new THREE.Vector2(1,0), //图片右下角
    new THREE.Vector2(1,1), //图片右上角
    new THREE.Vector2(0,1), //图片左上角
];

//设置纹理坐标
for(var m=0;m<cubeGeometry.faces.length;m+=1){
	cubeGeometry.faces[m].materialIndex = faceId;
	cubeGeometry.faceVertexUvs[0][m] = [uv[0],uv[1],uv[2]];
	faceId++;
}
console.log('uv',uv,cubeGeometry.faceVertexUvs);

cube = new THREE.Mesh(cubeGeometry,materials);
cube.autoRate = true;

// var box = new THREE.BoxHelper( cube, 0xffff00 );
// scene.add( box );
scene.add(cube);

var group = new THREE.Group();
group.add( cube );

var pointsGeometry = new THREE.Geometry();
//四个面的法线点
var normalPoints = [
	new THREE.Vector3(-r, r, r),
	new THREE.Vector3(-r, -r, -r),
	new THREE.Vector3(r, r, -r),
	new THREE.Vector3(r, -r, r)
];
pointsGeometry.vertices = normalPoints;

var pointsMaterial = new THREE.PointsMaterial( {
	color: 0xfffffff,
	size:0.5,
} );
var pointsField = new THREE.Points( pointsGeometry, pointsMaterial );
group.add( pointsField );
group.autoRate = true;
scene.add( group );

var originalPonits = [
	new THREE.Vector3(-r, r, r),
	new THREE.Vector3(-r, -r, -r),
	new THREE.Vector3(r, r, -r),
	new THREE.Vector3(r, -r, r)
];
console.log('originalPonits', originalPonits);

//监听当前属于哪个面
function checkCurFace(){
	var degCell = 2 * Math.PI / 360,
		orbitX = orbit.getPolarAngle(),
		orbitY = orbit.getAzimuthalAngle();
	var distance = [];//与相机位置的距离
	originalPonits.forEach(function (item, index) {
		var itemOldPoint = normalPoints[index];
		// console.log('itemOldPoint',itemOldPoint);
		var x = itemOldPoint.x,
			y = itemOldPoint.y,
			z = itemOldPoint.z,
			startX = Math.abs(Math.atan(y/z)),
			startY = Math.abs(Math.atan(x/z)),
			ralationX = group.rotation.x,
			ralationY = group.rotation.y,
			degX = startX + ralationX,
			degY = startY + ralationY,
			fR = Math.sqrt(Math.pow(x, 2) + Math.pow(z, 2)),//底部投影半径
			sR = Math.sqrt(Math.pow(y, 2) + Math.pow(z, 2)),//侧面投影半径
			cR = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2) + Math.pow(z, 2)); //向量点距中心的半径

		switch (index) {
			case 0:
				item.x = fR * Math.cos(degY) * (x > 0 ? 1 : -1);
				item.z = sR * Math.sin(degX) * (z > 0 ? 1 : -1);
				item.y = sR * Math.cos(degX) * (y > 0 ? 1 : -1);
				break;
			case 1:
				item.x = fR * Math.sin(degY) * (x > 0 ? 1 : -1);
				item.z = fR * Math.cos(degY) * (z > 0 ? 1 : -1);
				item.y = sR * Math.cos(degX) * (y > 0 ? 1 : -1);
				break;
			case 2:
				item.x = fR * Math.cos(degY) * (x > 0 ? 1 : -1);
				item.z = sR * Math.cos(degX) * (z > 0 ? 1 : -1);
				item.y = sR * Math.sin(degX) * (y > 0 ? 1 : -1);
				break;
			case 3:
				item.x = fR * Math.sin(degY) * (x > 0 ? 1 : -1);
				item.z = fR * Math.cos(degY) * (z > 0 ? 1 : -1);
				item.y = sR * Math.cos(degX) * (y > 0 ? 1 : -1);
				break;
			default:
				break;
		}

		// item.x = fR * (z / x > 0 ? Math.sin(degY) : Math.cos(degY)) * (x > 0 ? 1 : -1);
		// item.z = sR * (z / y > 0 ? Math.sin(degX) : Math.cos(degX)) * (z > 0 ? 1 : -1);
		// item.y = sR * (z / y > 0 ? Math.cos(degX) : Math.sin(degX)) * (y > 0 ? 1 : -1);

		console.log(x,y,z,'degX',degX, degX/degCell,'degY',degY, degY/degCell);

		var distanceX = camera.position.x - item.x,
			distanceY = camera.position.y - item.y,
			distanceZ = camera.position.z - item.z;
		// console.log('camera',camera.position.x,camera.position.y,camera.position.z);
		distance.push(Math.sqrt(Math.pow(distanceX, 2) + Math.pow(distanceY, 2) + Math.pow(distanceZ, 2)));
	});
	var minDistance = Math.min.apply(null, distance),
		curIndex = distance.indexOf(minDistance);
	console.log(
		'originalPonits', originalPonits,
		'normalPoints', normalPoints,
		'distance', distance,
		'minDistance', minDistance,
		'curIndex', curIndex,
	);

// var geometry = new THREE.Geometry();
// geometry.vertices = originalPonits;

// var pointsMaterial = new THREE.PointsMaterial( {
// 	color: 0xd9156d,
// 	size:0.5,
// 	opacity:0.1,
// } );
// var field = new THREE.Points( pointsGeometry, pointsMaterial );
// group.add( field );
// scene.add( group );

}


cube.on('click', function (ev) {
	group.autoRate = !group.autoRate;
	// console.log('click-ev', ev, 'group', group);
	checkCurFace();
});
cube.on('mouseover', function (ev) {
	group.autoRate = false;
	checkCurFace();
});
cube.on('mouseout', function (ev) {
	group.autoRate = true;
});


			var render = function () {

				requestAnimationFrame( render );

				var time = Date.now() * 0.001;
                
				if(group.autoRate){
					if(group.rotation.x < Math.PI*2){
						group.rotation.x += 0.01;
						group.rotation.y += 0.01;
					}else{
						group.rotation.x = 0;
						group.rotation.y = 0;
						// console.log('旋转一圈');
					}
					// checkCurFace();
				}
				

				renderer.render( scene, camera );
			};

			window.addEventListener( 'resize', function () {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}, false );

			render();

		</script>
	</body>
</html>
